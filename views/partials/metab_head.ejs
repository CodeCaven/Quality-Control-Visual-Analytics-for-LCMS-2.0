<head>
	<title>MPMF Quality Control</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!--<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">-->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" type="text/css" href="./stylesheets/style.css"  />
	<link rel="stylesheet" type="text/css" href="./stylesheets/w3.css"  />
	<script src="./javascripts/controlFunctions.js"></script>
	<script src="./javascripts/options.js"></script>
	<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
	<script type="text/javascript">

		// REFACTOR GENERAL
		// - change vars to lets and 'use strict'
		// - reorder function declarations
		// - drawing functions structure, data structures for stored tables etc
		// - use (of) loops for arrays (or normal loops fastest) and (in) loops for objects

		// NOTES
		// all_negative, all_positive and update_checkboxes draw the charts
		// they will call switchView if display view false
		
		google.charts.load('current', {packages: ['corechart','controls','table']});
		google.charts.setOnLoadCallback(drawAll);

		// line chart containers
		var all_dashboards = [];
		var all_datatables = [];
		var all_checks = [];
		var all_sliders = [];
		var all_chart_wrappers = [];
		var all_chart_names = [];
		
		// candle chart containers
		var all_candle_charts = [];
		var all_candle_datatables = [];
		var all_candle_line_datables = []; // could add logic to use all_datatables
		var all_candle_names = [];

		// table containers
		var all_tables_pos = [];
		var all_tables_neg = [];
		var all_tables_data = [];

		// initialise state variables
		var display_view = true; // true for dates, false for set interval
		var current_view = "Mass Error (ppm)"; 
		var last_display_index = -1; // candle charts current display index
		
		// get menu dict and initialise state variables
		var menu = <%-JSON.stringify(v_menu)%>;
		for(item in menu){
			var venue = item.toUpperCase();
			var menu_machines = menu[item];
			var machine = menu_machines[0].toUpperCase();
			break;
		}
		
		var start_count = 0; // init sliders check
		var checks = false; // init checkboxes (need by radios)

		var box_cols = []; // stores the indexes (in all_checks) of the checked boxes
		
		// create index lists for pos neg dataviews and checkboxes
		var pos_indexes = [0]; // first column dates
		var neg_indexes = [0];
		var pos_indexes_table = [0];
		var neg_indexes_table = [0];
		var pos_names = "<%=v_pos_names%>".split(",");
		var neg_names = "<%=v_neg_names%>".split(",");
		var pos_colours = <%-JSON.stringify(v_pos_colours)%>;
		var neg_colours = <%-JSON.stringify(v_neg_colours)%>;
		var modes = "<%=v_modes%>".split(",");
		var components = "<%=v_components%>".split(",");
		var metrics = "<%=v_metrics%>".split(",");
		var line_colours = [];
		var components_dt_index = [];
		var table_colours = "<%=v_table_colours%>".split(",");
		var headings = document.getElementsByClassName('heading');
		var line_overlays = document.getElementsByName('overlayLine');
		var candle_overlays = document.getElementsByName('overlayCandle');
		var table_overlays = document.getElementsByName('overlayTable');
		var all_options = {}; // store the options used by each chart in each view (needed for cloning issues)
		var all_options_switch = {};
		var all_options_candles = {};

		// create an object of component/modes for sorting by polarity (used by candles)
		var comp_obj = {};
		for(var i=0; i<components.length; i++){
			comp_obj[components[i]] = modes[i];
			box_cols.push(i); // initialise checked boxes array
		}
		
		// create index list for components in datatables
		for(var i =1; i < components.length*4; i += 4){
			components_dt_index.push(i);
		}

		// create list of pos and neg indexes
		for(var i = 0; i<modes.length;i++){
			if(modes[i] == 'P'){
				pos_indexes_table.push(components_dt_index[i]);
				pos_indexes.push(components_dt_index[i]);
				pos_indexes.push(components_dt_index[i]+1); // style
				pos_indexes.push(components_dt_index[i]+2); // tooltip
				pos_indexes.push(components_dt_index[i]+3); // uncert
			}
			else if(modes[i] == 'N'){
				neg_indexes_table.push(components_dt_index[i]);
				neg_indexes.push(components_dt_index[i]);
				neg_indexes.push(components_dt_index[i]+1); // style
				neg_indexes.push(components_dt_index[i]+2); // tooltip
				neg_indexes.push(components_dt_index[i]+3); //uncert
			}
		}

		// add interval columns
		var mach_col = (components.length*4) + 2;
		pos_indexes.push(mach_col+1);
		pos_indexes.push(mach_col+2);
		neg_indexes.push(mach_col+1);
		neg_indexes.push(mach_col+2);

		// used by box plots to deterimine colour
		function is_positive(name){
			for (p_name in pos_names){
				if(pos_names[p_name] == name){
					return true;
				}
			}
			return false;
		}

		// on ready first function called
		function drawAll() {
		
			// calls drawChart for data per metric
			// NOTE: js months start at 0, check for this
			// NOTE: ejs can't comment out code !
			// TESTING: correct nulls for metrics
			
			var input_line = <%-JSON.stringify(v_data)%>;
			var input_box = <%-JSON.stringify(v_box_data)%>;
			for(key in input_line){
				// convert string dates to dates
				for(arr in input_line[key]){
					input_line[key][arr][0] = new Date(input_line[key][arr][0]);
					for(var i = 1; i<input_line[key][arr].length-2; i+=4){
						// set nulls to previous value for uncertainty line
						if(input_line[key][arr][i] == null){
							if(arr != 0){
								input_line[key][arr][i] = input_line[key][arr-1][i];
							}
							//console.log(input_line[key][arr-1][i]);
						}
					}	
				}

				// normalised metrics have no box data
				if(key == 'Area (normalised)' || key == 'Height (normalised)'){
					box_data = [];
				}
				else{
					box_data = input_box[key];
				}
				// REFACTOR into create charts like proteomics??
				drawChart(input_line[key], key, box_data);
			}	
		}

		// change to proteomics page
		function changePage(){
			var new_path = "http://" + window.location.hostname + ":" + window.location.port + "/proteomics";
			window.location.assign(new_path);
		}


		// DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {
			
			// scroll page and sidebar to top
			document.documentElement.scrollTop = 0;
			document.getElementById('mySidebar').scrollTop = 0;

			// add machines to sidebar for current venue
			update_menu();

			// event listeners for candle arrow candles
			arrow_controls = document.getElementsByName('arrowButtons');
			for (var i = 0; i < arrow_controls.length; i++) {
				arrow_controls[i].addEventListener('click', updateCandles);
			}

			// set header to current state variables
			var v_header = document.getElementById('venueHeader');
			var m_header = document.getElementById('machineHeader');
			var l_header = document.getElementById('viewLabel');
			v_header.innerHTML = venue;
			m_header.innerHTML = machine;
			l_header.innerHTML = "<strong><b>"+current_view+"</b></strong>";
			
			// set header based on screen size
			setHeader();
			setTopMargin();


			// set radio buttons to neg as will load in last state regardless of html property
			var radios = document.getElementsByClassName('w3-radio');	
			for(var i =0; i<radios.length; i++){
				if(radios[i].value == 'Negative'){
					radios[i].checked = true;
				}
			}
			
		}, false);

		function update_menu(){
			// add machines to sidebar for current venue
			var parent = document.getElementById("machine");

			// first remove any previous machines
			while (parent.firstChild) {
				parent.removeChild(parent.firstChild);
			}

			// create and add the machine buttons
			for(var i=0; i < menu_machines.length; i++) {
				var new_button = document.createElement("button");
				new_button.innerHTML= menu_machines[i].toUpperCase();
				new_button.className = 'w3-btn w3-block w3-light-gray';
				new_button.onclick = function(){change(this);};
				parent.append(new_button);
			}
		}

		function radioUpdate(sender){
			//console.log("VIEW COLS B4" + view_cols.toString());
			//console.log("BOX COLS B4 " + box_cols.toString());
			// update all radio buttons
			var radios = document.getElementsByClassName('w3-radio');	
			for(var i =0; i<radios.length; i++){
				if(radios[i].value == sender.value){
					radios[i].checked = true;
				}
			}

			// set visibility properties for checks
			for(var i =0; i<all_checks.length; i++){
				for(var j=0;j<all_checks[i].length; j++){
					if(all_checks[i][j].id[0] == sender.value[0]){
						all_checks[i][j].style.visibility = "visible";
					}
					else{
						all_checks[i][j].style.visibility = "hidden";
					}
				}
			}

			// set display properties for panels
			var check_panels = document.getElementsByClassName('checkPanel');
			for(var i =0; i<check_panels.length; i++){
				var classes = check_panels[i].classList;
				
				if(classes.contains(sender.value)){
					check_panels[i].style.display = 'block';
				}
				else{
					check_panels[i].style.display = 'none';
				}
				
			}

			// if radio clicked before updateCheck is run need to create view cols (box cols is initialised)
			if(!checks){
				var view_cols = [0];
				if(sender.value == 'Positive'){
					for(var i = 0; i<pos_names.length; i++){
						var col = find_column_index(pos_names[i]);
						view_cols.push(col);
						view_cols.push(col + 1);
						view_cols.push(col + 2);
						view_cols.push(col + 3);
					}
				}
				else{
					for(var i = 0; i<neg_names.length; i++){
						var col = find_column_index(neg_names[i]);
						view_cols.push(col);
						view_cols.push(col + 1);
						view_cols.push(col + 2);
						view_cols.push(col + 3);
					}
				}
			}
			else{
				var view_cols = [0];
				for(var i=0; i<box_cols.length; i++){// use the box_cols (checked) to create view cols
					if(all_checks[0][box_cols[i]].style.visibility == 'visible'){
						var comp = all_checks[0][box_cols[i]].id.substring(all_checks[0][box_cols[i]].name.substring(9).length+1);
						var col = find_column_index(comp);
						view_cols.push(col);
						view_cols.push(col+1); // style
						view_cols.push(col+2); // tool
						view_cols.push(col+3); // uncertainty
					}
				}
			}

			// loading overlays
			for(var i = 0; i<line_overlays.length; i++){
				line_overlays[i].style.display = 'block';
			}

			// draw the charts
			for(var i = 0; i<all_dashboards.length; i++){
				init(all_checks[i]);
				update_checkboxes(all_chart_names[i], all_datatables[i], all_sliders[i], all_dashboards[i], all_chart_wrappers[i], view_cols, false);

				// check the chart boxes 
				for(var j = 0; j<box_cols.length; j++){
					all_checks[i][box_cols[j]].checked = true;
				}
				
			}
		}

		
		// callback for checkboxes
		function updateChecks(sender){
			
			var view_cols = [0]; 
			box_cols = []; // store indices of checked boxes
			checks = true; // for radios

			// find the chart index and id index of checked box
			// so can recheck if last one
			
			var sender_j = - 1;
			for(var i = 0; i<all_checks.length; i++){
				if (sender_j > 0){
					break;
				}
				if(all_checks[i][0].name == sender.target.name){
					var sender_i = i;
					for(var j =0; j<all_checks[i].length; j++){
						if(all_checks[i][j].id == sender.target.id){
							sender_j = j;
							break;	
						}
					}
				}
			}
			
			// find indexes of checked components and add to view
			for (var k = 0; k < all_checks[sender_i].length; k++) {
				if(all_checks[sender_i][k].checked){
					box_cols.push(k); // store the indices to check the boxes
					// get component name by stripping metric name from id
					if(all_checks[sender_i][k].style.visibility == 'visible'){ 
						var comp = all_checks[sender_i][k].id.substring(all_checks[sender_i][k].name.substring(9).length+1);
						var col = find_column_index(comp);
						view_cols.push(col);
						view_cols.push(col+1); // style
						view_cols.push(col+2); // tool
						view_cols.push(col+3); // uncertainty
						
					}
				}
			}
			
			// update all charts
			if(view_cols.length != 1){

				// loading overlays
				for(var i = 0; i<line_overlays.length; i++){
					line_overlays[i].style.display = 'block';
				}

				for(var i = 0; i<all_dashboards.length; i++){
					init(all_checks[i]);
					update_checkboxes(all_chart_names[i], all_datatables[i], all_sliders[i], all_dashboards[i], all_chart_wrappers[i], view_cols, false);

					// check the chart boxes 
					for(var j = 0; j<box_cols.length; j++){
						all_checks[i][box_cols[j]].checked = true;
					}
				}
			}
			// handle zero boxes
			else{
				//console.log(sender_j);
				all_checks[sender_i][sender_j].checked = true;
				box_cols.push(sender_j); // reset box and view cols
				view_cols.push(sender_j);
				view_cols.push(sender_j + 1);
				view_cols.push(sender_j + 2);
				view_cols.push(sender_j + 3);	
				}
		
		}

		function updateCandles(sender){
			var dir = sender.target.id.substring(0, 2);
			if(dir == 'l_'){
				last_display_index -= 1;
				if(last_display_index < 0){
					last_display_index = 0;
				}	
			}
			else if(dir == 'r_'){
				last_display_index += 1;
			}
			else if(dir == 'rr'){
				last_display_index = -1;
			}

			// update candle charts
			for(var i = 0; i<all_candle_charts.length; i++){
				draw_candle(all_candle_charts[i], all_candle_datatables[i], all_candle_line_datables[i], all_candle_names[i]);
			}
		}
		
		function updateFromResize(){
			google.visualization.events.trigger(all_sliders[0], 'statechange', {});
			google.visualization.events.trigger(all_sliders[0], 'statechange', {});

			// update candle charts
			for(var i = 0; i<all_candle_charts.length; i++){
				draw_candle(all_candle_charts[i], all_candle_datatables[i], all_candle_line_datables[i], all_candle_names[i]);
			}

			// update the heat maps (change -1)
			for(var i = 0; i<all_tables_neg.length; i++){
				draw_table(all_tables_data[i], all_tables_neg[i], 'N', tableOptions['startPage']);
				draw_table(all_tables_data[i], all_tables_pos[i], 'P', tableOptions['startPage']);
			}
		}


		function addAllOverlays(){
			// loading overlays line charts
			for(var i = 0; i<line_overlays.length; i++){
				line_overlays[i].style.display = 'block';
			}

			// loading overlays table charts
			for(var i = 0; i<table_overlays.length; i++){
				table_overlays[i].style.display = 'block';
			}
			
			// loading overlays candle charts 
			//var candle_overlays = document.getElementsByClassName('overlayCandle');
			for(var i = 0; i<candle_overlays.length; i++){
				candle_overlays[i].style.display = 'block';
			}
		}

		function change(sender){

			// determine button clicked and load new charts
			var buttonType = sender.parentNode.id;
		
			// change of venue
			if(buttonType == 'venue'){
				var new_venue = sender.innerHTML;
				if(new_venue != venue){ // only if new venue
					// loading overlays
					addAllOverlays();

					venue = new_venue
					var v_header = document.getElementById('venueHeader');
					v_header.innerHTML = venue;

					// update machines
					menu_machines = menu[venue];
					machine = menu_machines[0].toUpperCase();
					var m_header = document.getElementById('machineHeader');
					m_header.innerHTML = machine;
					update_menu();

					// half second delay to see overlays
					setTimeout(changeAllCharts, 500);
				}

			} // change machine
			else if(buttonType == 'machine'){
				
				var new_machine= sender.innerHTML;
				if(new_machine != machine){
					// loading overlays
					addAllOverlays();

					machine = new_machine;
					var header = document.getElementById('machineHeader');
					header.innerHTML = machine;

					// half second delay to see overlays
					setTimeout(changeAllCharts, 500);
				}
			}
		}
		
		// callback for venue dropdown
		// here not resetting to negative 
		function changeAllCharts(){

			// update line charts
			for(var i = 0; i<all_dashboards.length; i++){
				init(all_checks[i]); //(dt, dS, dash, checks, cw)
				all_negative(all_chart_names[i], all_datatables[i], all_sliders[i], all_dashboards[i], all_checks[i], all_chart_wrappers[i], false);
				// set checks and visibility
				// REFACTOR: repeated code below with radioUpdates()
				for(var j =0; j<all_checks[i].length; j++){
					if(all_checks[i][j].id[0] == 'P'){
						all_checks[i][j].checked = true;
						all_checks[i][j].style.visibility = 'hidden';
					}
					else{
						all_checks[i][j].style.visibility = 'visible';
					}
				}

				// set panels to display neg
				// set display properties for panels
				var check_panels = document.getElementsByClassName('checkPanel');
				for(var k =0; k<check_panels.length; k++){
					var classes = check_panels[k].classList;
					if(classes.contains('Negative')){
						check_panels[k].style.display = 'block';
					}
					else{
						check_panels[k].style.display = 'none';
					}
					
				}

				// reset radios and boolean
				var radios = document.getElementsByClassName('w3-radio');	
				for(var k =0; k<radios.length; k++){
					if(radios[k].value == 'Negative'){
						radios[k].checked = true;
					}
				}

				//reset box_cols and boolean
				checks = false;
				for(var k=0; k<components.length; k++){
					box_cols.push(k); 
				}
			}

			last_display_index = -1;
			// update candle charts
			for(var i = 0; i<all_candle_charts.length; i++){
				draw_candle(all_candle_charts[i], all_candle_datatables[i], all_candle_line_datables[i], all_candle_names[i]);
			}

			// update the heat maps
			for(var i = 0; i<all_tables_neg.length; i++){
				draw_table(all_tables_data[i], all_tables_neg[i], 'N', -1);
				draw_table(all_tables_data[i], all_tables_pos[i], 'P', -1);
			}	
		}

		function all_checked(charge){
			// checks if all checkboxes are checked for allCharts
			for(var i=0; i <all_checks[0].length; i ++){
				if(all_checks[0][i].id[0] == charge && !all_checks[0][i].checked){
						return false;
					
				}
			}
			return true;
		}

		// callback for select all button  
		function allCharts(){

			// determine current polarity
			var id = all_checks[0][0].id[0];
			var id_vis = all_checks[0][0].style.visibility;
			if(id == 'P' && id_vis == 'hidden'){
				var charge = 'N';
			}
			else if (id == 'P' && id_vis == 'visible'){
				var charge = 'P';
			}
			else if (id == 'N' && id_vis == 'hidden'){
				var charge = 'P';
			}
			else{ //(id == 'N' && id_vis == 'visible') 
				var charge = 'N';
			}
			
			if(!all_checked(charge)){
				
				// loading overlays
				for(var i = 0; i<line_overlays.length; i++){
					line_overlays[i].style.display = 'block';
				}

				if(charge == 'P'){
					for(var i = 0; i<all_dashboards.length; i++){
						init(all_checks[i]);
						all_positive(all_chart_names[i], all_datatables[i], all_sliders[i], all_dashboards[i], all_checks[i], all_chart_wrappers[i], true);
						
					}
					// merge pos cols with box cols
					var pos_box_cols = [0,1,2,3,4,5,6];
					box_cols = Array.from(new Set(pos_box_cols.concat(box_cols)));
					
					
				}
				else if(charge == 'N'){
					for(var i = 0; i<all_dashboards.length; i++){
						init(all_checks[i]);
						all_negative(all_chart_names[i], all_datatables[i], all_sliders[i], all_dashboards[i], all_checks[i], all_chart_wrappers[i], true);
						
					}
					// merge neg cols with box cols
					var neg_box_cols = [7,8,9,10,11,12,13,14,15,16]
					box_cols = Array.from(new Set(neg_box_cols.concat(box_cols)));
					
				}

				// check the boxes (REFACTOR: all neg will also check the neg boxes)
				for(var i =0; i<all_checks.length; i++){
					for(var j =0; i<all_checks[i].length; j++){
						all_checks[i][box_cols[j]].checked = true;
					}
				}
				
			}
		}

		// set all checks to false
		// needed or checkboxes behave badly
		function init(checks){
			for (var i = 0; i < checks.length; i++) {
				checks[i].checked = false;
			}
		}

		// datatable, dateslider,dashboard,checkboxes, chart wrappers, param(machine/venue)
		// REFACToR: pass in i instead of arrays ??
		// 5/03/2020 - Added name param so does not rely on Google charts tags (which change)
		function all_positive(chart_name, dt, dS, dash, checks, cw, param){
			if(display_view){

				// set options
				cw.setOptions(all_options[chart_name]);
				dS.setOptions(datepickerOptions);

				var view = new google.visualization.DataView(dt);

				// filter by venue (not needed if filtering by machine)
				//view.setRows(view.getFilteredRows([{column: mach_col-1, value:venue}]));
				
				// filter rows by machine 
				view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

				// filter by pos_indexes
				view.setColumns(pos_indexes);
				
				// set state of date slider(init only) and draw the dashboard
				if (start_count < metrics.length){

					var last_date = new Date(view.getFormattedValue(view.getNumberOfRows()-1,0));
					var first_date = new Date(view.getFormattedValue(0,0));
					dS.setState({range:{'start': first_date, 'end': last_date}});
					start_count ++;
				}
				
				// false for venue and machine
				if(!param){
					dS.setState({range:{'start': view.getValue(0, 0), 'end': view.getValue(view.getNumberOfRows() - 1,0)}});
				}

				dash.draw(view);
			}
			else{
				if(!param){ // change of venue
					switchView(chart_name, dt, cw, dS, dash, pos_indexes, dS.getState().range.start, dS.getState().range.end, true);
				} else{
					switchView(chart_name, dt, cw, dS, dash, pos_indexes, dS.getState().range.start, dS.getState().range.end, false);
				}
			}

			// check the boxes
			for (var i = 0; i < checks.length; i++) {
				if(checks[i].id[0] == 'P'){
					checks[i].checked = true;
				}
			}	
		}
		
		// Also used by change of venue/machine
		// REFACToR: pass in i instead of arrays??
		// 5/03/2020 - Added name param so does not rely on Google chart tags(which can change)
		function all_negative(chart_name, dt, dS, dash, checks, cw, param){
			if(display_view){

				// set options
				cw.setOptions(all_options[chart_name]);
				dS.setOptions(datepickerOptions);
				
				var view = new google.visualization.DataView(dt);
				
				// filter by venue
				//view.setRows(view.getFilteredRows([{column: mach_col-1, value:venue}]));
				
				// filter rows by machine (add if used)
				view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

				// filter by neg_indexes
				view.setColumns(neg_indexes);

				// set state of date slider and draw the dashboard
				
				if(start_count < metrics.length){

					var last_date = new Date(view.getValue(view.getNumberOfRows()-1,0));
					var first_date = new Date(view.getValue(0,0));
					
					dS.setState({range:{'start': first_date, 'end': last_date}});
					start_count ++;
				}

				// reset sliders for venue machine change
				if(!param){
					dS.setState({range:{'start': view.getValue(0, 0), 'end': view.getValue(view.getNumberOfRows() - 1,0)}});
				}
				dash.draw(view);
				
			}
			else{
				if(!param){ // change of venue
					switchView(chart_name, dt, cw, dS, dash, neg_indexes, dS.getState().range.start, dS.getState().range.end, true);
				} else{
					switchView(chart_name, dt, cw, dS, dash, neg_indexes, dS.getState().range.start, dS.getState().range.end, false);
				}
			}

			// check the boxes
			for (var i = 0; i < checks.length; i++) {
				if(checks[i].id[0] == 'N'){
					checks[i].checked = true;
				}
			}
		}

		// Also used by change of view (param true)
		// REFACToR: pass in i instead of arrays
		// 5/03/2020 - Added name param (see all negative/positive)
		function update_checkboxes(chart_name, dt, dS, dash, cw, vcols, param){
			
			// add interval columns
			vcols.push(mach_col+1);
			vcols.push(mach_col+2);

			if(display_view){

				// set options
				cw.setOptions(all_options[chart_name]);
				dS.setOptions(datepickerOptions);

				// create view
				var view = new google.visualization.DataView(dt);

				// filter by venue
				//view.setRows(view.getFilteredRows([{column: mach_col-1, value:venue}]));

				// filter rows by machine (add if used)
				view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

				// filter component columns (with annotations)
				view.setColumns(vcols);

				// switch back to normal view slider reset 
				// (google charts will return floats...parse int!)
				if(param){
					dS.setState({range:{'start': view.getValue(parseInt(dS.getState().range.start), 0), 'end': view.getValue(parseInt(dS.getState().range.end), 0)}});
				}
				dash.draw(view);
			}
			else{
				switchView(chart_name, dt, cw, dS, dash, vcols,dS.getState().range.start, dS.getState().range.end, false);
			}
		}
		
		// used by checkboxes in update
		function find_column_index(component){
			for(var i = 0; i < components.length; i++){
				if(components[i] == component){
					return components_dt_index[i];
				}
			}
			return false;
		}

		function get_previous_slider_dates(mname){
			// find first slider that isn't current and return its range
			for(var i = 0; i<all_sliders.length; i++){
				var slider_name = all_chart_names[i];//.gv.substr(12, all_sliders[i].gv.length);
				//console.log(slider_name);
				if (slider_name != mname){
					var prev_start = all_sliders[i].getState().range.start;
					var prev_end = all_sliders[i].getState().range.end;
					return {'start':prev_start, 'end': prev_end};
				}
			}
		}

		// update date sliders for all charts
		function update_sliders(start, end){

			// loading overlays
			for(var i = 0; i<line_overlays.length; i++){
				line_overlays[i].style.display = 'block';
			}

			for(var i =0; i < all_dashboards.length; i ++){
				
				var view_cols = [0]; 
				// find indexes of checked components
				for (var j = 0; j < all_checks[i].length; j++) {
					if(all_checks[i][j].checked && all_checks[i][j].style.visibility == 'visible'){
						var comp = all_checks[i][j].id.substring(all_checks[i][j].name.substring(9).length+1);
						var col = find_column_index(comp);
						view_cols.push(col);
						view_cols.push(col+1); //style
						view_cols.push(col+2); //tooltip
						view_cols.push(col+3); // uncertainty
					}
				}
				//console.log(view_cols);
				// add interval columns
				view_cols.push(mach_col+1);
				view_cols.push(mach_col+2);

				if(display_view){
					// create view
					var view = new google.visualization.DataView(all_datatables[i]);

					// filter by venue
					//view.setRows(view.getFilteredRows([{column: mach_col-1, value:venue}]));

					// filter rows by machine (add if used)
					view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

					// filter component columns,set state of slider and draw
					view.setColumns(view_cols);
					
					// set slider and redraw
					all_sliders[i].setState({range:{'start': start, 'end': end}});
					all_dashboards[i].draw(view);
				}
				else{
					switchView(all_chart_names[i],all_datatables[i], all_chart_wrappers[i], all_sliders[i], all_dashboards[i], view_cols, start, end, false);
				}
			}
		}
		
		// draw the box plots and last run 
		function draw_candle(c_chart, candle, ch_data, metric_name){
				//console.log(metric_name);
				var line_data_view =  new google.visualization.DataView(ch_data);
				var view = new google.visualization.DataView(candle, true);

				// filter by venue
				//line_data_view.setRows(line_data_view.getFilteredRows([{column: mach_col-1, value:venue}]));
				//view.setRows(view.getFilteredRows([{column: 4, value:venue}]));
				
			
				// filter rows by machine (add if used)
				line_data_view.setRows(line_data_view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));
				view.setRows(view.getFilteredRows([{column: 6, value:machine.toLowerCase()}]));

				// index of date to display
				if(last_display_index == -1){
					last_display_index = line_data_view.getNumberOfRows()-1;
				}
				else if(last_display_index > line_data_view.getNumberOfRows()-1){
					last_display_index = line_data_view.getNumberOfRows()-1;
				}

				var run_index = last_display_index;

				// hide/show arrow logic
				if(run_index == 0){
					var metric_arrow_left = document.getElementById("l_" + metric_name);
					metric_arrow_left.style.display = 'none';
				}
				else if(run_index == line_data_view.getNumberOfRows()-1){
					var metric_arrow_right = document.getElementById("r_" + metric_name);
					var metric_double_right = document.getElementById("rr_" + metric_name);
					metric_arrow_right.style.display = 'none';
					metric_double_right.style.display = 'none';
				}
				else{
					var metric_arrow_left = document.getElementById("l_" + metric_name);
					var metric_arrow_right = document.getElementById("r_" + metric_name);
					var metric_double_right = document.getElementById("rr_" + metric_name);
					metric_arrow_left.style.display = 'inline';
					metric_arrow_right.style.display = 'inline';
					metric_double_right.style.display = 'inline';
				}

				// only display double arrows ig greater than 2 away from end
				if(run_index >= line_data_view.getNumberOfRows()-2){
					var metric_double_right = document.getElementById("rr_" + metric_name);
					metric_double_right.style.display = 'none';
				}
				

				// convert to data table for write
				var view_data_table = view.toDataTable();

				// add column for last run line data
				var run_date = line_data_view.getValue(run_index, 0).toString().slice(0,25); // so legend displays date
				//console.log(run_date);
				view_data_table.insertColumn(3, 'number', run_date);
				view_data_table.insertColumn(4, {type:'string', role:'style'});
				view_data_table.insertColumn(5, {type: 'string', role: 'tooltip', 'p': {'html': true}});
				offset = 0; // for ann columns and certainty
				for(var i = 1; i < line_data_view.getNumberOfColumns()-4; i+=4){
					var run_data = line_data_view.getValue(run_index, i);
					var cert = line_data_view.getValue(run_index, i+3);
					//console.log(run_data);
					// handle missed values 
					if(!cert){
						run_data = 0;
						var style_string = 'point { size: 7; shape-type: circle; fill-color:black; }';
					}
					else if(is_positive(view_data_table.getValue(i-1 - offset, 0))){
						var style_string =  'point { size: 7; shape-type: square; fill-color:' + pos_colours[view_data_table.getValue(i-1 - offset, 0)];
					}
					else{
						var style_string = 'point { size: 7; shape-type: square; fill-color:' + neg_colours[view_data_table.getValue(i-1 - offset, 0)];
					}
					view_data_table.setValue(i-1 - offset, 3, run_data);
					view_data_table.setValue(i-1 - offset, 4, style_string);
					view_data_table.setValue(i-1 - offset, 5, create_candle_tooltip(run_date, view_data_table.getValue(i-1 - offset, 0), run_data));
					offset +=3;
				}

				// set run date on chart
				var display_elem = document.getElementById("dateDisplay_" + metric_name);
				display_elem.innerHTML = run_date;

				

				// convert back to view for filtering
				var view = new google.visualization.DataView(view_data_table, true);

				// select columns for box plot and line
				view.setColumns([0,1,2,3,4,5,6,7]);

				// sort by median desc
				view.setRows(view.getSortedRows({column: 1, desc: true}));

				
				// NOTE: filtering a view using set rows will filter from the data table it
				//       was created from, so need to convert to data table to "persist" view changes

				// back to datatable to persist median sort
				var view_data_table = view.toDataTable();
				
				// create view for polarity filtering
				var view = new google.visualization.DataView(view_data_table, true);

				// sort by polarity
				view.setRows(polarity_sort(view_data_table));

				// back to datatable to persist polarity sort
				var view_data_table = view.toDataTable();

				// remove undescores for display
				for(var i =0; i < view_data_table.getNumberOfRows(); i++){
					//console.log(view_data_table.getValue(i, 0));
					view_data_table.setValue(i, 0, view_data_table.getValue(i, 0).replace("_", " "));
				}
				
				// create view for final display
				var view = new google.visualization.DataView(view_data_table, true);

				// filter for individual charts if needed
				//view.setRows(view.getFilteredRows([{column: 0, value:'HEPES'}]));

				// options dict for candles
				var title = '';
				all_options_candles[metric_name] =  JSON.parse(JSON.stringify(candleOptionsTemplate));;

				if(metric_name == 'Mass Error (ppm)'){
					title = "ppm";
				}
				else if(metric_name == 'Mass Error (mDa)'){
					title = "mDa";
				}
				else if(metric_name == 'Retention Time'){
					title = "Minutes";
				}
				else if(metric_name == 'Area (normalised)'){
					title = "log_2(area)/" + "\n" +"(median_area)";
				}
				else if(metric_name == 'Height (normalised)'){
					title = "log_2(height)/" + "\n" +"(median_height)";
				}
				else if(metric_name == 'Full Width Half Maximum'){
					title = "Seconds";
				}
				all_options_candles[metric_name].vAxis.title = title;

				// draw the candle chart with line
				c_chart.draw(view, all_options_candles[metric_name]);

				function polarity_sort(unsorted){
					// function to sort by pos the neg
					// could probably refactor for an insertion sort complexity
					// by removing double loop...if time!

					sorted_rows = [];
					
					// loop for pos indexes
					for(var i = 0; i < unsorted.getNumberOfRows(); i+=1){
						var comp = unsorted.getValue(i, 0);
						if (comp_obj[comp] == 'P'){
							sorted_rows.push(i);
						}
					}

					// loop for neg indexes
					for(var i = 0; i < unsorted.getNumberOfRows(); i+=1){
						var comp = unsorted.getValue(i, 0);
						if (comp_obj[comp] == 'N'){
							sorted_rows.push(i);
						}
					}

					return sorted_rows;
				}
			}

		function create_candle_tooltip(date, component, value){
			if(value == 0){
				return '<div style="padding:5px 5px 5px 5px;">' +
								'<strong>' + date.toString().slice(0,25) + '</strong>' + '</br>' +
								'<strong>' + component + '</strong>' + ':' + '</br>' + 'NO DATA' +
								'</div>';
			}
			else{
				return '<div style="padding:5px 5px 5px 5px;">' +
								'<strong>' + date.toString().slice(0,25) + '</strong>' + '</br>' +
								'<strong>' + component + '</strong>' + ':' + '</br>' + parseFloat(value).toFixed(3).toString() +
								'</div>';
			}
		}
		
		function draw_table(dt, table, type, page){
			var table_view = new google.visualization.DataView(dt);

			// filter by venue
			//table_view.setRows(table_view.getFilteredRows([{column: mach_col-1, value:venue}]));
				
			// filter rows by machine (add if used)
			table_view.setRows(table_view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

			// filter by table columns
			if(type == 'P'){
				table_view.setColumns(pos_indexes_table);
				
			}else if(type == 'N'){
				table_view.setColumns(neg_indexes_table);
			}
			
			if(page > -1){
				tableOptions['startPage'] = page;
			}
			else{
				tableOptions['startPage'] = 0;
			}

			table.draw(table_view, tableOptions);
		}

		// Main function to draw charts initially, run for each metric displayed once
		function drawChart(chart_data, metric, box_data) {

			// get metric name from index
			var mname = metric;
			//console.log(mname);

			// Create dashboard instance
			var dashboard = new google.visualization.Dashboard(document.getElementById('dash_' + mname));

			// Create the line data
			var data = new google.visualization.DataTable();
			
			data.addColumn({type:'datetime' ,label:'Date Time'});

			for(var comp in components){
				data.addColumn({type: 'number', role: 'data', label:components[comp].replace("_"," ")});
				data.addColumn({type:'string', role:'style'});
				data.addColumn({'type': 'string', 'role': 'tooltip', 'p': {'html': true}});
				data.addColumn({type: 'boolean', role: 'certainty'});
			}
			data.addColumn('string', 'venue name');
			data.addColumn('string', 'machine name');
			data.addColumn({type : 'number', role :'interval'});
			data.addColumn({type : 'number', role :'interval'});

			// debug 2018-12-27T11:54:10.000Z has 53 cols row 199???..missed value not picking up server end
			//console.log(chart_data);
			data.addRows(chart_data);

			// date slider control wrapper
			var dateSlider = new google.visualization.ControlWrapper({
				controlType: 'ChartRangeFilter',
				containerId: 'datecontrol_' + mname
			});

			// event for slider changes
			google.visualization.events.addListener(dateSlider, 'statechange', function(event){
				if(!event.inProgress){
					var slider_start = dateSlider.getState().range.start;
					var slider_end = dateSlider.getState().range.end;
					
					
					if(slider_start.toString() != slider_end.toString()){
						update_sliders(slider_start, slider_end);	
					}
					else{
						// errors if the same so set to previous
						var previous = get_previous_slider_dates(mname);
						update_sliders(previous.start, previous.end);
						
					}
				}
			});
			
			// chart wrapper for line chart
			var lineChart = new google.visualization.ChartWrapper({
				chartType: 'LineChart',
				containerId: 'chart_' + mname
			});

			
			
			// set vaxis from template options and store as individual objects (else cloning issues)
			// do switch view options as here as well
			var title = '';
			all_options[mname] =  JSON.parse(JSON.stringify(chartOptionsTemplate));;
			all_options_switch[mname] =  JSON.parse(JSON.stringify(changeViewOptionsTemplate));

			if(mname == 'Mass Error (ppm)'){
				title = "ppm";
			}
			else if(mname == 'Mass Error (mDa)'){
				title = "mDa";
			}
			else if(mname == 'Retention Time'){
				title = "Minutes";
			}
			else if(mname == 'Area (normalised)'){
				title = "log_2(area)/" + "\n" +"(median_area)";
			}
			else if(mname == 'Height (normalised)'){
				title = "log_2(height)/" + "\n" +"(median_height)";
			}
			else if(mname == 'Full Width Half Maximum'){
				title = "Seconds";
			}
			all_options[mname].vAxis.title = title;
			all_options_switch[mname].vAxis.title = title;


			// event for ready, loading logic
			// find its overlay and set display to none
			google.visualization.events.addListener(lineChart, 'ready', function(){

				var chart_id = lineChart.getContainerId().slice(6, lineChart.getContainerId().length);
				//console.log(chart_id);
				for(var i = 0; i<line_overlays.length; i++){
					var overlay_id = line_overlays[i].id.slice(8, line_overlays[i].id.length);
					if (overlay_id == chart_id){
						line_overlays[i].style.display = 'none';
						//console.log(line_overlays[i]);
					}
				}
			});

			// event for chart changes explorer sync
			// see https://stackoverflow.com/questions/42235369/detect-zoom-event-for-a-google-line-chart
			google.visualization.events.addListener(lineChart, 'select', function(event){
				console.log(lineChart.getChart().getChartLayoutInterface());
				console.log(event);
			});

			// checkboxes event listeners
			var boxes = document.getElementsByName('components_'+ mname);
			for (var i = 0; i < boxes.length; i++) {
				boxes[i].addEventListener('click', updateChecks);
			}
		
			// bind dashboard elements and draw (controls, charts)
			dashboard.bind(dateSlider, lineChart);

			// collect dashboards and data tables..
			all_dashboards.push(dashboard);
			all_datatables.push(data);
			all_checks.push(boxes);
			all_sliders.push(dateSlider);
			all_chart_wrappers.push(lineChart);
			all_chart_names.push(mname);

			// initial display
			init(boxes);
			all_negative(mname, data, dateSlider, dashboard, boxes, lineChart, true);

			// check pos boxes too for their initial display
			for(var i =0; i<boxes.length; i++){
				if(boxes[i].id[0] == 'P'){
					boxes[i].checked = true;
				}
			}

			// Candle charts create and draw
			if(box_data.length > 0){
				var candle_data = new google.visualization.DataTable();
				
				candle_data.addColumn('string', 'component name');
				candle_data.addColumn('number', 'Median');
				candle_data.addColumn({type: 'string', role: 'tooltip', 'p': {'html': true}});
				candle_data.addColumn({type : 'number', role :'interval'});
				candle_data.addColumn({type : 'number', role :'interval'});
				candle_data.addColumn('string', 'venue name');
				candle_data.addColumn('string', 'machine name');
				candle_data.addRows(box_data);

				// candle chart
				var candle_chart = new google.visualization.ScatterChart(document.getElementById('candle_' + mname));
				
				// event for ready, loading logic
				// find its overlay and set display to none
				google.visualization.events.addListener(candle_chart, 'ready', function(){
					var chart_id = candle_chart.container.id.slice(7, candle_chart.container.id.length);
					for(var i = 0; i<candle_overlays.length; i++){
						var overlay_id = candle_overlays[i].id.slice(14, candle_overlays[i].id.length);
						if (overlay_id == chart_id){
							candle_overlays[i].style.display = 'none';
						}
					}
				});
				//console.log(candle_data.toJSON());
				draw_candle(candle_chart, candle_data, data, mname);
				
				// store candle info
				all_candle_charts.push(candle_chart);
				all_candle_datatables.push(candle_data);
				all_candle_line_datables.push(data);
				all_candle_names.push(mname);

			}else{
				// HEAT MAPS

				// Scales
				var scale_data = new google.visualization.DataTable();

				for(var i = 0; i<table_colours.length; i++){
					scale_data.addColumn('string');
				}
				scale_data.addRows(1);

				// scale display, changed to strings (not needed in end), last number is formatted below for display
				var cell_data = ["-4", "-2.5", "-1.5", "-0.9", "-0.7", "-0.5", "-0.3", "-0.15", "0.0", "0.15", "0.3", "0.5", "0.7", "0.9", "1.5", "2.5", "4.0"];

				// 18 colour ranges
				var scale_range = [-1000, -3.0001, -2.0001, -1.0001, -0.8001, -0.6001, -0.4001, -0.2001, -0.1001, 0.1001, 0.2001, 0.4001, 0.6001, 0.8001, 1.0001, 2.0001, 3.0001, 1000]

				// colours for map, change ranges
				var formatter = new google.visualization.ColorFormat();
				for(var i =0; i < table_colours.length; i++){
					formatter.addRange(scale_range[i], scale_range[i+1], table_colours[i], table_colours[i]);
				}

				// diff. for scale table
				var scale_formatter = new google.visualization.ColorFormat();
				for(var i =0; i < table_colours.length; i++){
					scale_formatter.addRange(scale_range[i], scale_range[i+1], 'white', table_colours[i]);
				}

				// date formatter
				var date_formatter = new google.visualization.DateFormat({pattern: "MMM dd, yy"});
				date_formatter.format(data,0);
				
				var table_scale_view = new google.visualization.DataView(scale_data);
				
				// apply colour formats
				for(i=1; i<data.getNumberOfColumns()-4; i+=4){
					formatter.format(data, i);
				}

				// add scale data and formatting
				for(var i = 0; i<cell_data.length; i++){
					scale_data.setCell(0, i, cell_data[i]);
					scale_formatter.format(scale_data, i);
				}
				
				// change display in scale
				scale_data.setFormattedValue(0, cell_data.length - 1, ">3");
				scale_data.setFormattedValue(0, 0, "<-3");
				
				// draw the scale
				var table_scale = new google.visualization.Table(document.getElementById('table_scale' + mname));
				table_scale.draw(table_scale_view, tableScaleOptions);
				
				// create the tables
				var table_pos = new google.visualization.Table(document.getElementById('table_P' + mname));
				var table_neg = new google.visualization.Table(document.getElementById('table_N' + mname));

				// page change events
				google.visualization.events.addListener(table_pos, 'page', function(event){
					for(var i = 0; i<all_tables_data.length; i++){
						draw_table(all_tables_data[i], all_tables_neg[i], 'N', event.page);
						draw_table(all_tables_data[i], all_tables_pos[i], 'P', event.page);

					}
				});

				google.visualization.events.addListener(table_neg, 'page', function(event){
					for(var i = 0; i<all_tables_data.length; i++){
						draw_table(all_tables_data[i], all_tables_neg[i], 'N', event.page);
						draw_table(all_tables_data[i], all_tables_pos[i], 'P', event.page);

					}
				});

				// event for ready, loading logic POS
				// find its overlay and set display to none, works here but not in change view/machine
				google.visualization.events.addListener(table_pos, 'ready', function(){
					var chart_id = table_pos.container.id.slice(6, table_pos.container.id.length);
					//console.log(chart_id);
					for(var i = 0; i<table_overlays.length; i++){
						var overlay_id = table_overlays[i].id.slice(13, table_overlays[i].id.length);
						//console.log(overlay_id);
						if (overlay_id == chart_id){
							table_overlays[i].style.display = 'none';
						}
					}
				});

				// event for ready, loading logic NEG
				// find its overlay and set display to none, works here but not in change view/machine
				google.visualization.events.addListener(table_neg, 'ready', function(){
					var chart_id = table_neg.container.id.slice(6, table_neg.container.id.length);
					for(var i = 0; i<table_overlays.length; i++){
						var overlay_id = table_overlays[i].id.slice(13, table_overlays[i].id.length);
						if (overlay_id == chart_id){
							table_overlays[i].style.display = 'none';
						}
					}
				});
				
				// draw the tables
				draw_table(data, table_pos, 'P', -1);
				draw_table(data, table_neg, 'N', -1);

				// store for updates
				all_tables_pos.push(table_pos);
				all_tables_neg.push(table_neg);
				all_tables_data.push(data);
			}	
		}
		
		

			// SWITCH VIEW
			// Function to draw display_view=false interval dates
			// All drawing functions will call this function to handle display_view=false
			// REFACTOR: options logic to just chnaging object like table page events
			// 			: pass in i
			// 5/03/2020- Added name param as per other functions

			function switchView(chart_name, dt, cw, ds, dash, indexes, start, end, cv){ // datatable, chart wrapper, dateslider, dashboard, 
				var view = new google.visualization.DataView(dt);
				var hticks = [];
				var count = -1;
				var switch_name = chart_name;
				
				// filter by venue
				//view.setRows(view.getFilteredRows([{column: mach_col-1, value:venue}]));

				// filter by machine
				view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));


				var cols = [];
				for(var i = 1; i< dt.getNumberOfColumns(); i+=1){
					cols.push(i);
				}
				
				// add column of numbers, get domain populates hticks too
				cols.unshift({type: 'number', label: dt.getColumnLabel(0), calc: getDomain});
				
				// set new view with number domain instead of dates
				view.setColumns(cols);

				// convert to dt 
				var view_data_table = view.toDataTable();

				// set formatted values for tool tips
				var date_tool_options = { year: 'numeric', month: 'short', day: 'numeric' , hour: '2-digit', minute: '2-digit', second: '2-digit'};
				for(var i = 0; i<view_data_table.getNumberOfRows(); i++){
					view_data_table.setFormattedValue(i, 0, hticks[i].toLocaleDateString(undefined, date_tool_options));
				}
				
				// set up date hticks for display (not implemented)
				//var date_axis_options = { year: 'numeric', month: 'short', day: 'numeric'};
				//for(var i =0; i<hticks.length; i++){
					//format = hticks[i].toLocaleDateString(undefined, date_axis_options);
					//hticks[i] = {v:i,f:format};
				//}
				
				// convert bck to view for filtering
				var new_view = new google.visualization.DataView(view_data_table);
				
				// filter
				
				new_view.setColumns(indexes);

				// find slider end and start indexes from dates (or just set)
				var s_index = -1;
				var e_index = -1;
				if(typeof start == "object"){
					
					end_s = end.toLocaleDateString(undefined, date_tool_options);
					start_s = start.toLocaleDateString(undefined, date_tool_options);
					
					
					for(var i = 0; i<new_view.getNumberOfRows(); i ++){
						if(end_s == new_view.getFormattedValue(i,0)){
							e_index = i;
							break;
						}	
						if(start_s == new_view.getFormattedValue(i,0)){
							s_index = i;
						}
					}
				} else{
					// from sliders when already in switched mode
					e_index = end;
					s_index = start;
				}
				
				// catch slider range errors and reset 
				if(e_index == s_index){
					e_index = new_view.getNumberOfRows() - 1;
					s_index = 0;
				}
				
				// change of venue reset sliders
				if(cv){
					e_index = new_view.getNumberOfRows() - 1;
					s_index = 0;
				}

				// set new options
				cw.setOptions(all_options_switch[switch_name]);
				ds.setOptions(changeViewSliderOptions);
				
				ds.setState({range:{'start': s_index, 'end': e_index}});
				dash.draw(new_view);

				// callback for calc
				function getDomain(dt, row){
					// can't format here
					hticks.push(dt.getValue(row,0));
					count++;
					return count;
				}
				
			}
			
			// button callback change view
			function changeView(){

				// loading overlays
				for(var i = 0; i<line_overlays.length; i++){
					line_overlays[i].style.display = 'block';
				}
				
				display_view = !display_view;
				for(var i = 0; i<all_dashboards.length; i++){
					var view_cols = [0];
					// find indexes of checked components
					
					for (var j = 0; j < all_checks[i].length; j++) {
						if(all_checks[i][j].checked && all_checks[i][j].style.visibility == 'visible'){
							var comp = all_checks[i][j].id.substring(all_checks[i][j].name.substring(9).length+1);
							var col = find_column_index(comp);
							view_cols.push(col);
							view_cols.push(col+1); // style
							view_cols.push(col+2); // tooltip
							view_cols.push(col+3); // uncertainty
						}
					}
					update_checkboxes(all_chart_names[i],all_datatables[i], all_sliders[i], all_dashboards[i], all_chart_wrappers[i], view_cols, true);
				}
			}
			
			
  </script>
</head>
