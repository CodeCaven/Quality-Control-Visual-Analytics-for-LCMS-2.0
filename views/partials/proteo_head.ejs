<head>
	<title>MPMF Quality Control</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!--<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">-->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!--cloud fare for glyphs-->
	<link rel="stylesheet" type="text/css" href="./stylesheets/style.css"  />
	<link rel="stylesheet" type="text/css" href="./stylesheets/w3.css"  />
	<script src="./javascripts/controlFunctions.js"></script>
	<script src="./javascripts/options.js"></script>
	<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
	<script type="text/javascript">

		// REFACTOR GENERAL
		// - change vars to lets and 'use strict'
		// - reorder function declarations
		// - drawing functions structure, data structures for stored tables etc
		// - use (of) loops for arrays (or normal loops fastest) and (in) loops for objects
		// - import this script ??

		// NOTES
		// all_peptides and update_checkboxes and update_sliders draw the charts
		// they will call switchView if display view false
		
		google.charts.load('current', {packages: ['corechart','controls','table']});
		google.charts.setOnLoadCallback(drawAll);

		// line chart containers
		var all_dashboards = [];
		var all_datatables = [];
		var all_checks = [];
		var all_sliders = [];
		var all_chart_wrappers = [];
		var all_chart_names = [];
		
		// candle chart containers
		var all_candle_charts = [];
		var all_candle_datatables = [];
		var all_candle_line_datables = []; // could add logic to use all_datatables
		var all_candle_names = [];

		// table containers , heat maps
		var all_tables_data = [];
		var all_tables = [];

		// morpheus line chart containers
		var all_morph_dashboards = [];
		var all_morph_datatables = [];
		var all_morph_sliders = [];
		var all_morph_chart_wrappers = [];
		var all_morph_names = [];

		// initialise state variables
		var display_view = true; // true for dates, false for set interval (start true else logic change)
		var current_view = "Mass Error (ppm)"; 
		var last_display_index = -1; // candle charts current display index
		
		// get menu dict and initialise state variables
		var menu = <%-JSON.stringify(v_menu)%>;
		for(item in menu){
			var venue = item.toUpperCase();
			var menu_machines = menu[item];
			var machine = menu_machines[0].toUpperCase();
			break;
		}
		
		var start_count = 0; // init sliders check
		var start_count_morph = 0; // init sliders check

		
		// create index lists for pos neg dataviews and checkboxes
		var components = "<%=v_components%>".split(",");
		var component_colours = <%-JSON.stringify(v_component_colours)%>;
		var metrics = "<%=v_metrics%>".split(",");
		var morph_metrics = "<%=v_morph_metrics%>".split(",");
		var line_colours = [];
		var components_dt_index = [];
		var heat_filter_view = [];
		var table_colours = "<%=v_table_colours%>".split(",");
		var headings = document.getElementsByClassName('heading');
		var line_overlays = document.getElementsByName('overlayLine');
		var candle_overlays = document.getElementsByName('overlayCandle');
		var table_overlays = document.getElementsByName('overlayTable');
		var morpheus_overlays = document.getElementsByName('overlayMorpheus');
		var all_options = {}; // store the options used by each chart in each view (needed for cloning issues)
		var all_options_switch = {};
		var all_options_candles = {};
		
		
		// create index list for components in datatables
		for(var i =1; i < components.length*4; i += 4){
			components_dt_index.push(i);
			heat_filter_view.push(i);
		}

		heat_filter_view.unshift(0);

		// create column filtering lists (removes machine and venue naming before drawing)
		var filter_view = [0]; // like pos/neg indexes in metabolomics
		
		for(var i=1; i < components.length*4; i+=4){
			filter_view.push(i);
			filter_view.push(i+1); // style
			filter_view.push(i+2); //ann
			filter_view.push(i+3); //cert
		}

		// add interval columns
		var mach_col = (components.length*4) + 2; // 2 for venue,machine
		filter_view.push(mach_col+1);
		filter_view.push(mach_col+2);

		
		// on ready first function called
		function drawAll() {
		
			// calls drawChart for data per metric
			// NOTE: js months start at 0, check for this
			// NOTE: ejs can't comment out code !
			// TESTING: correct nulls for metrics
			
			var input_line = <%-JSON.stringify(v_data)%>;
			var input_box = <%-JSON.stringify(v_box_data)%>;
			for(key in input_line){
			//console.log(input_line[key]);
				// convert string dates to dates
				for(arr in input_line[key]){
					input_line[key][arr][0] = new Date(input_line[key][arr][0]);
					for(var i = 1; i<input_line[key][arr].length-2; i+=4){
						// set nulls to previous value for uncertainty line
						if(input_line[key][arr][i] == null){
							if(arr != 0){
								input_line[key][arr][i] = input_line[key][arr-1][i];
							}
							//console.log(input_line[key][arr-1][i]);
						}
					}
						
				}

				// normalised metrics have no box data
				if(key == 'Area (normalised)' || key == 'Height (normalised)'){
					box_data = [];
				}
				else{
					box_data = input_box[key];
				}

				// refactored createChart not in metabolomics
				createChart(input_line[key], key, box_data);
			}
			createAllMorphCharts();	
		}

		// change to metabolomics page
		function changePage(){
			var new_path = "http://" + window.location.hostname + ":" + window.location.port + "/metabolomics";
			window.location.assign(new_path);
		}


		// DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {

			// scroll page and sidebar to top and set view
			document.documentElement.scrollTop = 0;
			document.getElementById('mySidebar').scrollTop = 0;
			//document.documentElement.style.overflow = 'hidden';

			// add machines to sidebar for current venue
			update_menu();

			// add MS1 header to metric menu
			var parent = document.getElementById('MS');
			var new_node = document.createElement('p');
			var top_h_rule = document.createElement('hr');
			var bottom_h_rule = document.createElement('hr');
			top_h_rule.style.width = '100%';
			top_h_rule.classList = "w3-round w3-white"
			bottom_h_rule.style.width = '100%';
			bottom_h_rule.classList = "w3-round w3-white";
			new_node.classList = "w3-center w3-large w3-text-white";
			new_node.innerHTML = '<strong>LC-MS METRICS</strong>';
			new_node.style.textShadow = "5px 5px 0 #444";

			new_node.append(bottom_h_rule);
			new_node.prepend(top_h_rule);
			parent.prepend(new_node);

			// add MS2 header to metric menu
			var new_node2 = document.createElement('p');
			var top_h_rule2 = document.createElement('hr');
			var bottom_h_rule2 = document.createElement('hr');
			top_h_rule2.style.width = '100%';
			top_h_rule2.classList = "w3-round w3-white";
			bottom_h_rule2.style.width = '100%';
			bottom_h_rule2.classList = "w3-round w3-white";
			bottom_h_rule2.id = "ms1bottom";
			new_node2.classList = "w3-center w3-large w3-text-white";
			new_node2.innerHTML = '<strong>MS2 METRICS</strong>';
			new_node2.style.textShadow = "5px 5px 0 #444";

			new_node2.append(bottom_h_rule2);
			new_node2.prepend(top_h_rule2);
			parent.append(new_node2);

			// add morpheus metrics to sidebar menu
			var new_line = document.createElement('br');
			
			for(let i = 0; i<morph_metrics.length; i++){
				var new_link = document.createElement('a');
				new_link.href = "#" + morph_metrics[i];
				new_link.classList = "w3-bar-item w3-btn w3-center";
				new_link.innerHTML = morph_metrics[i];
				parent.append(new_link);
			}


			// event listeners for candle arrow candles and colour
			arrow_controls = document.getElementsByName('arrowButtons');
			for (var i = 0; i < arrow_controls.length; i++) {
				arrow_controls[i].addEventListener('click', updateCandles);
				arrow_controls[i].style.backgroundColor = "#c6b8b8";
			}

			// set header to current state variables
			var v_header = document.getElementById('venueHeader');
			var m_header = document.getElementById('machineHeader');
			var l_header = document.getElementById('viewLabel');
			v_header.innerHTML = venue;
			m_header.innerHTML = machine;
			l_header.innerHTML = "<strong><b>"+current_view+"</b></strong>";
			
			// set header and margin based on screen size
			setHeader();
			setTopMargin();
			
		}, false);

		function update_menu(){
			// add machines to sidebar for current venue
			var parent = document.getElementById("machine");

			// first remove any previous machines
			while (parent.firstChild) {
				parent.removeChild(parent.firstChild);
			}

			// create and add the machine buttons
			for(var i=0; i < menu_machines.length; i++) {
				var new_button = document.createElement("button");
				new_button.innerHTML= menu_machines[i].toUpperCase();
				new_button.className = 'w3-btn w3-block w3-light-gray';
				new_button.onclick = function(){change(this);};
				parent.append(new_button);
			}
		}

    

		// callback for checkboxes
		function updateChecks(sender){
		
			var view_cols = [0]; 
			var box_cols = []; // store indices of checked boxes

			// find the chart index and id index of checked box
			// so can recheck if last one
			var sender_j = - 1;
			for(var i = 0; i<all_checks.length; i++){
				if (sender_j > 0){
					break;
				}
				if(all_checks[i][0].name == sender.target.name){
					var sender_i = i;
					for(var j =0; j<all_checks[i].length; j++){
						if(all_checks[i][j].id == sender.target.id){
							sender_j = j;
							break;	
						}
					}
				}
			}
			
			// find indexes of checked components and add to view
			for (var k = 0; k < all_checks[sender_i].length; k++) {
				if(all_checks[sender_i][k].checked){
					// get component name by stripping metric name from id
					var comp = all_checks[sender_i][k].id.substring(all_checks[sender_i][k].name.substring(11).length+1);
					var col = find_column_index(comp);
					view_cols.push(col);
					view_cols.push(col+1); // style
					view_cols.push(col+2); // ann
					view_cols.push(col+3); // uncertainty
					box_cols.push(k); // store the indices to check the boxes
				}
			}
			
			// update all charts
			if(view_cols.length != 1){

				// loading overlays
				for(var i = 0; i<line_overlays.length; i++){
					line_overlays[i].style.display = 'block';
				}

				for(var i = 0; i<all_dashboards.length; i++){
					init(all_checks[i]);
					update_checkboxes(all_datatables[i], all_sliders[i], all_dashboards[i], all_chart_wrappers[i], view_cols, false, all_chart_names[i]);

					// check the chart boxes 
					for(var j = 0; j<box_cols.length; j++){
						all_checks[i][box_cols[j]].checked = true;
					}
				}
			}
			// handle zero boxes
			else{
				console.log(sender_j);
				all_checks[sender_i][sender_j].checked = true;
			}
			
		}

		function updateCandles(sender){
			var dir = sender.target.id.substring(0, 2);
			if(dir == 'l_'){
				last_display_index -= 1;
				if(last_display_index < 0){
					last_display_index = 0;
				}	
			}
			else if(dir == 'r_'){
				last_display_index += 1;
			}
			else if(dir == 'rr'){
				last_display_index = -1;
			}


			// update candle charts
			for(var i = 0; i<all_candle_charts.length; i++){
				draw_candle(all_candle_charts[i], all_candle_datatables[i], all_candle_line_datables[i], all_candle_names[i]);
			}

		}

		function addAllOverlays(){
			// loading overlays line charts
			for(var i = 0; i<line_overlays.length; i++){
				line_overlays[i].style.display = 'block';
			}

			// loading overlays table charts
			for(var i = 0; i<table_overlays.length; i++){
				table_overlays[i].style.display = 'block';
			}
			
			// loading overlays candle charts 
			for(var i = 0; i<candle_overlays.length; i++){
				candle_overlays[i].style.display = 'block';
			}

			// loading overlays morpheus charts 
			for(var i = 0; i<morpheus_overlays.length; i++){
				morpheus_overlays[i].style.display = 'block';
			}

		}
		
		function updateFromResize(){

			// trigger line chart redraw (updates Morpheus too)
			google.visualization.events.trigger(all_sliders[0], 'statechange', {});
			google.visualization.events.trigger(all_sliders[0], 'statechange', {});

			// update candle charts
			for(var i = 0; i<all_candle_charts.length; i++){
				draw_candle(all_candle_charts[i], all_candle_datatables[i], all_candle_line_datables[i], all_candle_names[i]);
			}

			// update the heat maps
			for(var i = 0; i<all_tables.length; i++){
				draw_table(all_tables_data[i], all_tables[i], tableOptions['startPage']);
			}
			
		}

		function change(sender){

			// determine button clicked and load new charts
			var buttonType = sender.parentNode.id;
		
			// change of venue
			if(buttonType == 'venue'){
				var new_venue = sender.innerHTML;
				if(new_venue != venue){ // only if new venue
					// loading overlays
					addAllOverlays();

					venue = new_venue
					var v_header = document.getElementById('venueHeader');
					v_header.innerHTML = venue;

					// update machines
					menu_machines = menu[venue];
					machine = menu_machines[0].toUpperCase();
					var m_header = document.getElementById('machineHeader');
					m_header.innerHTML = machine;
					update_menu();

					// half second delay to see overlays
					setTimeout(changeAllCharts, 500);
				}

			} // change machine
			else if(buttonType == 'machine'){
				
				var new_machine= sender.innerHTML;
				if(new_machine != machine){
					// loading overlays
					addAllOverlays();

					machine = new_machine;
					var header = document.getElementById('machineHeader');
					header.innerHTML = machine;

					// half second delay to see overlays
					setTimeout(changeAllCharts, 500);
				}
			}
		}
		
		// callback for venue 
		function changeAllCharts(){
			// update line charts
			// update control boxes
			for(var i = 0; i<all_dashboards.length; i++){
				init(all_checks[i]); //(dt, dS, dash, checks, cw)
				all_peptides(all_datatables[i], all_sliders[i], all_dashboards[i], all_checks[i], all_chart_wrappers[i], false, all_chart_names[i]);
			}

			// check the control boxes..no control bixes now
			//init(control_boxes);
			//for(var j = 0; j<control_boxes.length; j++){
				//control_boxes[j].checked = true;
				
			//}
			
			last_display_index = -1;
			// update candle charts
			for(var i = 0; i<all_candle_charts.length; i++){
				draw_candle(all_candle_charts[i], all_candle_datatables[i], all_candle_line_datables[i], all_candle_names[i]);
			}

			// update the heat maps
			for(var i = 0; i<all_tables.length; i++){
				draw_table(all_tables_data[i], all_tables[i], -1);
			}
			
			// update the morpheus charts
			for(var i = 0; i<all_morph_datatables.length; i++){
				draw_morph_chart(all_morph_datatables[i], all_morph_sliders[i], all_morph_dashboards[i], all_morph_chart_wrappers[i], false, all_morph_names[i]);
			}	
		}

		function all_checked(){
			// checks if all checkboxes are checked for allCharts
			for(var i=0; i <all_checks[0].length; i ++){
				if(all_checks[0][i].checked == false){
					return false
				}
			}
			return true
		}

		// callback for all charts button control 
		function allCharts(){
			
			if(!all_checked()){ // only if there is an unchecked box
				// loading overlays
				for(var i = 0; i<line_overlays.length; i++){
					line_overlays[i].style.display = 'block';
				}

				// update all the charts
				for(var i = 0; i<all_dashboards.length; i++){
					init(all_checks[i]);
					all_peptides(all_datatables[i], all_sliders[i], all_dashboards[i], all_checks[i], all_chart_wrappers[i], true, all_chart_names[i]);
				}

			}
			
		}

		// set all checks to false
		function init(checks){
			for (var i = 0; i < checks.length; i++) {
				checks[i].checked = false;
			}
		}

		// datatable, dateslider,dashboard,checkboxes, chart wrappers, param(machine/venue)
		// REFACToR: pass in i instead of arrays ??
		// 5/03/20 - added name param so does not use Google chart tags (which changed)
		
		function all_peptides(dt, dS, dash, checks, cw, param, chart_name){
			if(display_view){

				// set options 
				cw.setOptions(all_options[chart_name]);
				dS.setOptions(datepickerOptions);

				var view = new google.visualization.DataView(dt);
				
				// filter rows by machine 
				view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));
				
				// filter columns for drawing
				view.setColumns(filter_view);

				// set state of date slider(init only) and draw the dashboard
				if (start_count < metrics.length){

					// set the slider range, implement logic here
					var last_date = new Date(view.getFormattedValue(view.getNumberOfRows()-1,0));
					var first_date = new Date(view.getFormattedValue(0,0));
					dS.setState({range:{'start': first_date, 'end': last_date}});
					start_count ++;
				}
				
				// false for venue and machine
				if(!param){
					dS.setState({range:{'start': view.getValue(0, 0), 'end': view.getValue(view.getNumberOfRows() - 1,0)}});
				}
				
				dash.draw(view);
			}
			else{
				if(!param){ // change of venue REFACTOR take out ifelse and use param logic
					switchView(chart_name, dt, cw, dS, dash, filter_view, dS.getState().range.start, dS.getState().range.end, true, mach_col);
				} else{
					switchView(chart_name, dt, cw, dS, dash, filter_view, dS.getState().range.start, dS.getState().range.end, false, mach_col);
				}
			}

			// check the boxes
			for (var i = 0; i < checks.length; i++) {
					checks[i].checked = true;
				
			}	
		}
		
		// Also used by change of view (param true)
		// REFACToR: pass in i instead of arrays
		// 5/03/20 - added name param so does not use Google chart tags (which changed)
		function update_checkboxes(dt, dS, dash, cw, vcols, param, chart_name){
			
			// add interval columns
			vcols.push(mach_col+1);
			vcols.push(mach_col+2);

			if(display_view){
				
				// set options
				cw.setOptions(all_options[chart_name]);
				dS.setOptions(datepickerOptions);

				// create view
				var view = new google.visualization.DataView(dt);

				// filter by venue
				//view.setRows(view.getFilteredRows([{column: (components.length*3)+1, value:venue}]));

				// filter rows by machine (add if used)
				view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

				// filter component columns 
				view.setColumns(vcols);

				// switch back to normal view slider reset 
				// (google charts will return floats...parse int!)
				if(param){
					dS.setState({range:{'start': view.getValue(parseInt(dS.getState().range.start), 0), 'end': view.getValue(parseInt(dS.getState().range.end), 0)}});
				}
				dash.draw(view);
			}
			else{
				switchView(chart_name, dt, cw, dS, dash, vcols,dS.getState().range.start, dS.getState().range.end, false, mach_col);
			}
		}
		
		// used by checkboxes in update
		function find_column_index(component){
			for(var i = 0; i < components.length; i++){
				if(components[i] == component){
					return components_dt_index[i];
				}
			}
			return false;
		}

		function get_previous_slider_dates(mname){
			// find first slider that isn't current and return its range
			for(var i = 0; i<all_sliders.length; i++){
				var slider_name = all_chart_names[i]; //all_sliders[i].gv.substr(12, all_sliders[i].gv.length);
				if (slider_name != mname){
					var prev_start = all_sliders[i].getState().range.start;
					var prev_end = all_sliders[i].getState().range.end;
					return {'start':prev_start, 'end': prev_end};
				}
			}
		}

		// update date sliders for all charts
		function update_sliders(start, end){


			// loading overlays
			for(var i = 0; i<line_overlays.length; i++){
				line_overlays[i].style.display = 'block';
			}

			for(var i =0; i < all_dashboards.length; i ++){
				
				var view_cols = [0]; 
				// find indexes of checked components
				for (var j = 0; j < all_checks[i].length; j++) {
					if(all_checks[i][j].checked){
						var comp = all_checks[i][j].id.substring(all_checks[i][j].name.substring(11).length+1);
						var col = find_column_index(comp);
						view_cols.push(col);
						view_cols.push(col+1); //style
						view_cols.push(col+2); // ann
						view_cols.push(col+3); // uncertainty
					}
				}

				// add interval columns
				view_cols.push(mach_col+1);
				view_cols.push(mach_col+2);

				if(display_view){
					// create view
					var view = new google.visualization.DataView(all_datatables[i]);

					// filter by venue
					//view.setRows(view.getFilteredRows([{column: (components.length*3)+1, value:venue}]));

					// filter rows by machine (add if used)
					view.setRows(view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));
					
					// filter component columns,set state of slider and draw
					view.setColumns(view_cols);
					
					// set slider and redraw
					all_sliders[i].setState({range:{'start': start, 'end': end}});
					all_dashboards[i].draw(view);
				}
				else{
					switchView(all_chart_names[i], all_datatables[i], all_chart_wrappers[i], all_sliders[i], all_dashboards[i], view_cols, start, end, false, mach_col);
				}
			}
			
			// redraw morph charts (add chart ready listener to use)
			// loading overlays
			for(var i = 0; i<morpheus_overlays.length; i++){
				morpheus_overlays[i].style.display = 'block';
			}
			
			view_cols = [0,1,2,3,4,5,6,7,10,11];
			for(var i =0; i < all_morph_dashboards.length; i ++){
				
				if(display_view){
					// create view
					var view = new google.visualization.DataView(all_morph_datatables[i]);

					// filter by venue
					//view.setRows(view.getFilteredRows([{column: (components.length*3)+1, value:venue}]));

					// filter rows by machine (add if used)
					view.setRows(view.getFilteredRows([{column: 9, value:machine.toLowerCase()}]));
					
					// filter component columns,set state of slider and draw
					view.setColumns(view_cols);
					
					// set slider and redraw
					all_morph_sliders[i].setState({range:{'start': start, 'end': end}});
					all_morph_dashboards[i].draw(view);
				}
				else{
					switchView(all_morph_names[i], all_morph_datatables[i], all_morph_chart_wrappers[i], all_morph_sliders[i], all_morph_dashboards[i], view_cols, start, end, false, 9);
				}
			}
		}
		
		// draw the box plots and last run 
		function draw_candle(c_chart, candle, ch_data, metric_name){
				//console.log(metric_name);
				var line_data_view =  new google.visualization.DataView(ch_data);
				var view = new google.visualization.DataView(candle, true);
				
				// filter by venue
				//line_data_view.setRows(line_data_view.getFilteredRows([{column: (components.length*3)+1, value:venue}]));
				//view.setRows(view.getFilteredRows([{column: 4, value:venue}]));
				
			
				// filter rows by machine (add if used)
				line_data_view.setRows(line_data_view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));
				view.setRows(view.getFilteredRows([{column: 6, value:machine.toLowerCase()}]));

				// index of date to display
				if(last_display_index == -1){
					last_display_index = line_data_view.getNumberOfRows()-1;
				}
				else if(last_display_index > line_data_view.getNumberOfRows()-1){
					last_display_index = line_data_view.getNumberOfRows()-1;
				}

				var run_index = last_display_index;

				// hide/show arrow logic
				if(run_index == 0){
					var metric_arrow_left = document.getElementById("l_" + metric_name);
					metric_arrow_left.style.display = 'none';
				}
				else if(run_index == line_data_view.getNumberOfRows()-1){
					var metric_arrow_right = document.getElementById("r_" + metric_name);
					var metric_double_right = document.getElementById("rr_" + metric_name);
					metric_arrow_right.style.display = 'none';
					metric_double_right.style.display = 'none';
				}
				else{
					var metric_arrow_left = document.getElementById("l_" + metric_name);
					var metric_arrow_right = document.getElementById("r_" + metric_name);
					var metric_double_right = document.getElementById("rr_" + metric_name);
					metric_arrow_left.style.display = 'inline';
					metric_arrow_right.style.display = 'inline';
					metric_double_right.style.display = 'inline';
				}

				// only display double arrows ig greater than 2 away from end
				if(run_index >= line_data_view.getNumberOfRows()-2){
					var metric_double_right = document.getElementById("rr_" + metric_name);
					metric_double_right.style.display = 'none';
				}

				

				// convert to data table for write
				var view_data_table = view.toDataTable();

				// add column for last run line data 
				var run_date = line_data_view.getValue(run_index, 0).toString().slice(0,25); // so legend displays date
				view_data_table.insertColumn(3, 'number', run_date);
				view_data_table.insertColumn(4, {type:'string', role:'style'});
				view_data_table.insertColumn(5, {type: 'string', role: 'tooltip', 'p': {'html': true}});
				offset = 0; // for ann columns and certainty and style
		
				for(var i = 1; i < line_data_view.getNumberOfColumns()-4; i+=4){
			
					var run_data = line_data_view.getValue(run_index, i);
					var cert = line_data_view.getValue(run_index, i+3);
					
					// handle missed values by checking certainty boolean
					if(!cert){
						run_data = 0;
						var style_string = 'point { size: 7; shape-type: circle; fill-color:black; }';
					}
					else{
						var style_string = 'point { size: 7; shape-type: square; fill-color:' +  component_colours[view_data_table.getValue(i-1 - offset, 0)] +'; }';
					}
					//console.log(view_data_table.getValue(i-1 - offset, 0));
					view_data_table.setValue(i-1 - offset, 3, run_data);
					view_data_table.setValue(i-1 - offset, 4, style_string);
					view_data_table.setValue(i-1 - offset, 5, create_candle_tooltip(run_date, view_data_table.getValue(i-1 - offset, 0), run_data));
					offset +=3;
					
				}

				// set run date on chart
				var display_elem = document.getElementById("dateDisplay_" + metric_name);
				display_elem.innerHTML = run_date;
				
				// convert back to view for filtering
				var view = new google.visualization.DataView(view_data_table, true);

				// select columns for box plot and line
				view.setColumns([0,1,2,3,4,5,6,7]);

				// sort by median desc (not wanted for proteomics)
				//view.setRows(view.getSortedRows({column: 1, desc: true}));

				
				// NOTE: filtering a view using set rows will filter from the data table it
				//       was created from, so need to convert to data table to "persist" view changes

				// back to datatable to remove underscores
				var view_data_table = view.toDataTable();

				// remove undescores for display
				for(var i =0; i < view_data_table.getNumberOfRows(); i++){
					//console.log(view_data_table.getValue(i, 0));
					view_data_table.setValue(i, 0, view_data_table.getValue(i, 0).replace("_", " "));
				}
				
				// create view  final display
				var view = new google.visualization.DataView(view_data_table, true);

				// filter for individual charts if needed
				//view.setRows(view.getFilteredRows([{column: 0, value:'HEPES'}]));
				
				

				// draw the candle chart with line
				c_chart.draw(view, all_options_candles[metric_name]);

			}

		function create_candle_tooltip(date, component, value){
			if(value == 0){
				return '<div style="padding:5px 5px 5px 5px;">' +
								'<strong>' + date.toString().slice(0,25) + '</strong>' + '</br>' +
								'<strong>' + component + '</strong>' + ':' + '</br>' + 'NO DATA' +
								'</div>';
			}
			else{
				return '<div style="padding:5px 5px 5px 5px;">' +
								'<strong>' + date.toString().slice(0,25) + '</strong>' + '</br>' +
								'<strong>' + component + '</strong>' + ':' + '</br>' + parseFloat(value).toFixed(3).toString() +
								'</div>';
			}
		}
		
		
		function draw_table(dt, table, page){
			var table_view = new google.visualization.DataView(dt);

			// filter by venue
			//table_view.setRows(table_view.getFilteredRows([{column: (components.length*3)+1, value:venue}]));
				
			// filter rows by machine (add if used)
			table_view.setRows(table_view.getFilteredRows([{column: mach_col, value:machine.toLowerCase()}]));

			// filter columns for drawing
			table_view.setColumns(heat_filter_view);

			if(page > -1){
				tableOptions['startPage'] = page;
			}
			else{
				tableOptions['startPage'] = 0;
			}

			table.draw(table_view, tableOptions);
		}

		function createChart(chart_data, metric, box_data) {
			
			var mname = metric;
			
			// Create dashboard instance
			var dashboard = new google.visualization.Dashboard(document.getElementById('dash_' + mname));

			// Create the line data REFACTOR rename as used by createBoxes and createHeatMaps
			var data = new google.visualization.DataTable();
			
			data.addColumn({type:'datetime' ,label:'Date Time'});

			for(var comp in components){
				data.addColumn({type: 'number', role: 'data', label:components[comp].replace("_"," ")});
				data.addColumn({type:'string', role:'style'});
				data.addColumn({'type': 'string', 'role': 'tooltip', 'p': {'html': true}});
				data.addColumn({type: 'boolean', role: 'certainty'});
			}
			data.addColumn('string', 'venue name');
			data.addColumn('string', 'machine name');
			data.addColumn({type : 'number', role :'interval'});
			data.addColumn({type : 'number', role :'interval'});

			
			data.addRows(chart_data);

			// date slider control wrapper
			var dateSlider = new google.visualization.ControlWrapper({
				controlType: 'ChartRangeFilter',
				containerId: 'datecontrol_' + mname
			});

			dateSlider.setOptions(datepickerOptions);

			// event for slider changes
			google.visualization.events.addListener(dateSlider, 'statechange', function(event){
				if(!event.inProgress){
					var slider_start = dateSlider.getState().range.start;
					var slider_end = dateSlider.getState().range.end;
					
					
					if(slider_start.toString() != slider_end.toString()){
						update_sliders(slider_start, slider_end);	
					}
					else{
						// errors if the same so set to previous
						var previous = get_previous_slider_dates(mname);
						update_sliders(previous.start, previous.end);
						
					}
				}
			});
			
			// chart wrapper for line chart
			var lineChart = new google.visualization.ChartWrapper({
				chartType: 'LineChart',
				containerId: 'chart_' + mname
			});

			// set vaxis from template options and store as individual objects (else cloning issues)
			// do switch view options as here as well
			var title = '';
			all_options[mname] =  JSON.parse(JSON.stringify(chartOptionsTemplate));;
			all_options_switch[mname] =  JSON.parse(JSON.stringify(changeViewOptionsTemplate));

			if(mname == 'Mass Error (ppm)'){
				title = "ppm";
			}
			else if(mname == 'Mass Error (mDa)'){
				title = "mDa";
			}
			else if(mname == 'Retention Time'){
				title = "Minutes";
			}
			else if(mname == 'Area (normalised)'){
				title = "log_2(area)/" + "\n" +"(median_area)";
			}
			else if(mname == 'Height (normalised)'){
				title = "log_2(height)/" + "\n" +"(median_height)";
			}
			else if(mname == 'Full Width Half Maximum'){
				title = "Seconds";
			}
			all_options[mname].vAxis.title = title;
			all_options_switch[mname].vAxis.title = title;

			// event for ready, loading logic
			// find its overlay and set display to none
			google.visualization.events.addListener(lineChart, 'ready', function(){

				var chart_id = lineChart.getContainerId().slice(6, lineChart.getContainerId().length);
				//console.log(chart_id);
				for(var i = 0; i<line_overlays.length; i++){
					var overlay_id = line_overlays[i].id.slice(8, line_overlays[i].id.length);
					if (overlay_id == chart_id){
						line_overlays[i].style.display = 'none';
						//console.log(line_overlays[i]);
					}
				}
			});

			// event for chart changes explorer sync
			// see https://stackoverflow.com/questions/42235369/detect-zoom-event-for-a-google-line-chart
			google.visualization.events.addListener(lineChart, 'select', function(event){
				console.log(lineChart.getChart().getChartLayoutInterface());
				console.log(event);
			});

			// checkboxes event listeners
			var boxes = document.getElementsByName('components_'+ mname);
			for (var i = 0; i < boxes.length; i++) {
				boxes[i].addEventListener('click', updateChecks);
			}
		
			// all peptides button listener
			// hidden in interface
			var pep_button = document.getElementById("Pep_"+ mname);
			pep_button.addEventListener('click', buttonUpdate);


			// button callbacks 
			// hidden in interface currently
			function buttonUpdate(sender){
				//loading overlay
				var chart_id = sender.target.id;
				for(var i = 0; i<line_overlays.length; i++){
					var overlay_id = line_overlays[i].id.slice(8, line_overlays[i].id.length);
					if (overlay_id == chart_id){
						line_overlays[i].style.display = 'block';
						
					}
				}
				init(boxes);
				all_peptides(data, dateSlider, dashboard, boxes, lineChart, true, mname);
			}
			
			
			
			// bind dashboard elements and draw (controls, charts)
			dashboard.bind(dateSlider, lineChart);

			// collect dashboards and data tables..
			all_dashboards.push(dashboard);
			all_datatables.push(data);
			all_checks.push(boxes);
			all_sliders.push(dateSlider);
			all_chart_wrappers.push(lineChart);
			all_chart_names.push(mname);

			// initial display
			init(boxes);
			all_peptides(data, dateSlider, dashboard, boxes, lineChart, true, mname);

			if(box_data.length > 0){
					createBoxes(box_data, key, data);
				}
				else{
					createHeatMaps(chart_data, metric, data);
			}
		}

		function createBoxes(box_data, metric, data){
			
			var mname = metric;

			var candle_data = new google.visualization.DataTable();
				
			candle_data.addColumn('string', 'component name');
			candle_data.addColumn('number', 'Median');
			candle_data.addColumn({type: 'string', role: 'tooltip', 'p': {'html': true}});
			candle_data.addColumn({type : 'number', role :'interval'});
			candle_data.addColumn({type : 'number', role :'interval'});
			candle_data.addColumn('string', 'venue name');
			candle_data.addColumn('string', 'machine name');
			candle_data.addRows(box_data);

			// candle chart
			var candle_chart = new google.visualization.ScatterChart(document.getElementById('candle_' + mname));
			
			// event for ready, loading logic
			// find its overlay and set display to none
			google.visualization.events.addListener(candle_chart, 'ready', function(){
				var chart_id = candle_chart.container.id.slice(7, candle_chart.container.id.length);
				for(var i = 0; i<candle_overlays.length; i++){
					var overlay_id = candle_overlays[i].id.slice(14, candle_overlays[i].id.length);
					if (overlay_id == chart_id){
						candle_overlays[i].style.display = 'none';
					}
				}
			});
			// options dict for candles
			var title = '';
			all_options_candles[mname] =  JSON.parse(JSON.stringify(candleOptionsTemplate));;

			if(mname == 'Mass Error (ppm)'){
				title = "ppm";
			}
			else if(mname == 'Mass Error (mDa)'){
				title = "mDa";
			}
			else if(mname == 'Retention Time'){
				title = "Minutes";
			}
			else if(mname == 'Area (normalised)'){
				title = "log_2(area)/" + "\n" +"(median_area)";
			}
			else if(mname == 'Height (normalised)'){
				title = "log_2(height)/" + "\n" +"(median_height)";
			}
			else if(mname == 'Full Width Half Maximum'){
				title = "Seconds";
			}
			all_options_candles[mname].vAxis.title = title;

			draw_candle(candle_chart, candle_data, data, mname);
			
			// store candle info
			all_candle_charts.push(candle_chart);
			all_candle_datatables.push(candle_data);
			all_candle_line_datables.push(data);
			all_candle_names.push(mname);
		}

		function createHeatMaps(chart_data, metric, data){
			// HEAT MAPS
			var mname = metric;
			// Scales
			var scale_data = new google.visualization.DataTable();

			for(var i = 0; i<table_colours.length; i++){
				scale_data.addColumn('string');
			}
			scale_data.addRows(1);

			// scale display, changed to strings (not needed in end), last number is formatted below for display
			var cell_data = ["-4", "-2.5", "-1.5", "-0.9", "-0.7", "-0.5", "-0.3", "-0.15", "0.0", "0.15", "0.3", "0.5", "0.7", "0.9", "1.5", "2.5", "4.0"];

			// 18 colour ranges
			var scale_range = [-1000, -3.0001, -2.0001, -1.0001, -0.8001, -0.6001, -0.4001, -0.2001, -0.1001, 0.1001, 0.2001, 0.4001, 0.6001, 0.8001, 1.0001, 2.0001, 3.0001, 1000]

			// colours for map, change ranges
			var formatter = new google.visualization.ColorFormat();
			for(var i =0; i < table_colours.length; i++){
				formatter.addRange(scale_range[i], scale_range[i+1], table_colours[i], table_colours[i]);
			}

			// diff. for scale table
			var scale_formatter = new google.visualization.ColorFormat();
			for(var i =0; i < table_colours.length; i++){
				scale_formatter.addRange(scale_range[i], scale_range[i+1], 'white', table_colours[i]);
			}

			// date formatter
			var date_formatter = new google.visualization.DateFormat({pattern: "MMM dd, yy"});
			date_formatter.format(data,0);
			
			var table_scale_view = new google.visualization.DataView(scale_data);
			
			// apply colour formats
			for(i=1; i<data.getNumberOfColumns()-2; i+=4){
				formatter.format(data, i);
			}

			// add scale data and formatting
			for(var i = 0; i<cell_data.length; i++){
				scale_data.setCell(0, i, cell_data[i]);
				scale_formatter.format(scale_data, i);
			}
			
			// change display in scale
			scale_data.setFormattedValue(0, cell_data.length - 1, ">3");
			scale_data.setFormattedValue(0, 0, "<-3");
			
			// draw the scale
			var table_scale = new google.visualization.Table(document.getElementById('table_scale' + mname));
			table_scale.draw(table_scale_view, tableScaleOptions);
			
			// create the tables
			var table = new google.visualization.Table(document.getElementById('table_' + mname));

			// page change events
			google.visualization.events.addListener(table, 'page', function(event){
				//draw_table(data, table, event.page);
				// update the heat maps
				for(var i = 0; i<all_tables.length; i++){
					draw_table(all_tables_data[i], all_tables[i], event.page);
				}
			});


			// event for ready, loading logic POS
			// find its overlay and set display to none, works here but not in change view/machine

			// WATCH slice here
			google.visualization.events.addListener(table, 'ready', function(){
				var chart_id = table.container.id.slice(6, table.container.id.length);
				//console.log(chart_id);
				for(var i = 0; i<table_overlays.length; i++){
					var overlay_id = table_overlays[i].id.slice(13, table_overlays[i].id.length);// slices off overlayTable
		
					if (overlay_id == chart_id){
						table_overlays[i].style.display = 'none';
					}
				}
			});
			
			// draw the tables
			draw_table(data, table, -1);

			// store for updates
			all_tables.push(table);
			all_tables_data.push(data);
		}
		
		function createAllMorphCharts(){
			var input_morph = <%-JSON.stringify(v_morph_data)%>;
			for(metric in input_morph){
				//console.log(metric);
				//console.log(input_morph[metric]);

				// convert string dates to dates
				for(arr in input_morph[metric]){
					input_morph[metric][arr][0] = new Date(input_morph[metric][arr][0]);
					// set nulls to previous value for uncertainty line
					if(input_morph[metric][arr][1] == null){
						if(arr != 0){
							input_morph[metric][arr][1] = input_morph[metric][arr-1][1];
				
						}
					}	
				}
				createMorphChart(input_morph[metric], metric);
			}
		}

		function createMorphChart(chart_data, metric){
			var mname = metric;

			// Create dashboard instance
			var dashboard = new google.visualization.Dashboard(document.getElementById('dash_' + mname));

			// Create the line data table
			var data_table = new google.visualization.DataTable();
			
			data_table.addColumn({type:'datetime' ,label:'Date Time'});
			data_table.addColumn({type: 'number', role: 'data', label:'Hela Digest'});
			data_table.addColumn({type:'string', role:'style'});
			data_table.addColumn({'type': 'string', 'role': 'tooltip', 'p': {'html': true}});
			data_table.addColumn({type: 'boolean', role: 'certainty'});
			data_table.addColumn({type: 'number', role: 'data', label:'Median'});
			data_table.addColumn({type:'string', role:'style'});
			data_table.addColumn({'type': 'string', 'role': 'tooltip', 'p': {'html': true}});			
			data_table.addColumn('string', 'venue name');
			data_table.addColumn('string', 'machine name');
			data_table.addColumn({type : 'number', role :'interval'});
			data_table.addColumn({type : 'number', role :'interval'});
			data_table.addRows(chart_data);

			// date slider control wrapper
			var dateSlider = new google.visualization.ControlWrapper({
				controlType: 'ChartRangeFilter',
				containerId: 'datecontrol_' + mname
			});


			// event for slider changes ADD when dates for morph are equal to mzmine peptides
			google.visualization.events.addListener(dateSlider, 'statechange', function(event){
				if(!event.inProgress){
					
					// NOTE: will need to change get_previous function to check for morph sliders
					var slider_start = dateSlider.getState().range.start;
					var slider_end = dateSlider.getState().range.end;
					
					
					if(slider_start.toString() != slider_end.toString()){
						update_sliders(slider_start, slider_end);	
					}
					else{
						// errors if the same so set to previous
						var previous = get_previous_slider_dates(mname);
						update_sliders(previous.start, previous.end);
						
					}
					
				}
			});
			
			// chart wrapper for line chart
			var lineChart = new google.visualization.ChartWrapper({
				chartType: 'LineChart',
				containerId: 'chart_' + mname
			});

			

			// set and keep options and vaxis
			all_options[mname] =  JSON.parse(JSON.stringify(chartOptionsTemplate));;
			all_options_switch[mname] =  JSON.parse(JSON.stringify(changeViewOptionsTemplate));
			all_options[mname].vAxis.title = 'Count';
			all_options_switch[mname].vAxis.title = 'Count';
			all_options[mname].intervals.color = '#add8e6 ';
			all_options_switch[mname].intervals.color = '#add8e6';

			lineChart.setOptions(all_options[mname]);

			// event for ready, loading logic
			// find its overlay and set display to none
			google.visualization.events.addListener(lineChart, 'ready', function(){

				var chart_id = lineChart.getContainerId().slice(6, lineChart.getContainerId().length);
				//console.log(chart_id + "CHARTID");
				for(var i = 0; i<morpheus_overlays.length; i++){
					var overlay_id = morpheus_overlays[i].id.slice(8, morpheus_overlays[i].id.length);
					//console.log(overlay_id);
					if (overlay_id == chart_id){
						morpheus_overlays[i].style.display = 'none';
						//console.log(morpheus_overlays[i]);
					}
				}
			});

			// bind dashboard elements and draw (controls, charts)
			dashboard.bind(dateSlider, lineChart);

			// draw the chart
			draw_morph_chart(data_table, dateSlider, dashboard, lineChart, false, mname);
			

			// collect dashboards and data tables..
			all_morph_dashboards.push(dashboard);
			all_morph_datatables.push(data_table);
			all_morph_sliders.push(dateSlider);
			all_morph_chart_wrappers.push(lineChart);
			all_morph_names.push(mname);

		}
		
		function draw_morph_chart(dt, dS, dash, cw, param, chart_name){
			
			if(display_view){

				dS.setOptions(datepickerOptions);
				cw.setOptions(all_options[chart_name]);

				var view = new google.visualization.DataView(dt);
				
				// filter rows by machine 
				view.setRows(view.getFilteredRows([{column: 9, value:machine.toLowerCase()}]));
				
				// filter columns for drawing
				view.setColumns([0,1,2,3,4,5,6,7,10,11]);

				// set state of date slider(init only) and draw the dashboard
				if (start_count_morph < morph_metrics.length){

					// set the slider range, implement logic here
				
					var last_date = new Date(view.getFormattedValue(view.getNumberOfRows()-1,0));
					var first_date = new Date(view.getFormattedValue(0,0));
					dS.setState({range:{'start': first_date, 'end': last_date}});
					start_count_morph ++;
				}

				// false for change of venue or machine where sliders are reset
				if(!param){
					dS.setState({range:{'start': view.getValue(0, 0), 'end': view.getValue(view.getNumberOfRows() - 1,0)}});
				}
				else{// else has come from change view
					dS.setState({range:{'start': view.getValue(parseInt(dS.getState().range.start), 0), 'end': view.getValue(parseInt(dS.getState().range.end), 0)}});
				}
				dash.draw(view);
			}
			else{
				var v_cols = [0,1,2,3,4,5,6,7,10,11];
				if(!param){ // change of venue REFACTOR take out ifelse and use param logic
					switchView(chart_name,dt, cw, dS, dash, v_cols, dS.getState().range.start, dS.getState().range.end, true, 9);
				} else{
					switchView(chart_name,dt, cw, dS, dash, v_cols, dS.getState().range.start, dS.getState().range.end, false, 9);
				}
			}
		}

		// SWITCH VIEW
		// Function to draw display_view=false interval dates
		// All drawing functions will call this function to handle display_view=false
		// REFACTOR: options logic to just chnaging object like table page events
		// 			: pass in i

		function switchView(chart_name, dt, cw, ds, dash, indexes, start, end, cv, machine_index){ 
		 
			var view = new google.visualization.DataView(dt);
			var hticks = [];
			var count = -1;
			var switch_name = chart_name;

			// REFACTOR remove mach_idex from args as global var now

			// filter by venue
			//view.setRows(view.getFilteredRows([{column: (components.length*3)+1, value:venue}]));

			// filter by machine
			view.setRows(view.getFilteredRows([{column: machine_index, value:machine.toLowerCase()}]));


			var cols = [];
			for(var i = 1; i< dt.getNumberOfColumns(); i+=1){
				cols.push(i);
			}
			
			// add column of numbers
			cols.unshift({type: 'number', label: dt.getColumnLabel(0), calc: getDomain});
			
			// set new view with number domain instead of dates
			view.setColumns(cols);

			// convert to dt 
			var view_data_table = view.toDataTable();

			// set formatted values for tool tips
			var date_tool_options = { year: 'numeric', month: 'short', day: 'numeric' , hour: '2-digit', minute: '2-digit', second: '2-digit'};
			for(var i = 0; i<view_data_table.getNumberOfRows(); i++){
				view_data_table.setFormattedValue(i, 0, hticks[i].toLocaleDateString(undefined, date_tool_options));
			}
			
			// set up date hticks for display (not implemented)
			var date_axis_options = { year: 'numeric', month: 'short', day: 'numeric'};
			for(var i =0; i<hticks.length; i++){
				format = hticks[i].toLocaleDateString(undefined, date_axis_options);
				hticks[i] = {v:i,f:format};
			}
			
			// convert bck to view for filtering
			var new_view = new google.visualization.DataView(view_data_table);
			
			// filter (all columns or current view cols)
			new_view.setColumns(indexes);

			// find slider end and start indexes from dates (or just set)
			var s_index = end;
			var e_index = start;
			if(typeof start == "object"){
				// will run on first switch
				end_s = end.toLocaleDateString(undefined, date_tool_options);
				start_s = start.toLocaleDateString(undefined, date_tool_options);
				
				
				for(var i = 0; i<new_view.getNumberOfRows(); i ++){
					if(end_s == new_view.getFormattedValue(i,0)){
						e_index = i;
						break;
					}	
					if(start_s == new_view.getFormattedValue(i,0)){
						s_index = i;
					}
				}
			}
			else {
					// will run when sliders used in switched mode
					e_index = end;
					s_index = start;
				}
			
			// catch slider range errors and reset 
			if(e_index == s_index){
				e_index = new_view.getNumberOfRows() - 1;
				s_index = 0;
			}
			
			// change of venue reset sliders
			if(cv){
				e_index = new_view.getNumberOfRows() - 1;
				s_index = 0;
			}


			// set new options
			// REFACTOR: could maybe just change hAxis properties??
			cw.setOptions(all_options_switch[switch_name]);
			ds.setOptions(changeViewSliderOptions);
			
			ds.setState({range:{'start': s_index, 'end': e_index}});
			dash.draw(new_view);

			// callback for calc
			function getDomain(dt, row){
				// can't format here
				hticks.push(dt.getValue(row,0));
				count++;
				return count;
			}
			
		}
		
		// button callback change view
		function changeView(){

			// loading overlays line
			for(var i = 0; i<line_overlays.length; i++){
				line_overlays[i].style.display = 'block';
			}

			// loading overlays morpheus
			for(var i = 0; i<morpheus_overlays.length; i++){
				morpheus_overlays[i].style.display = 'block';
			}
			
			
			display_view = !display_view;

			// update line charts
			for(var i = 0; i<all_dashboards.length; i++){
				var view_cols = [0];
				// find indexes of checked components
				
				for (var j = 0; j < all_checks[i].length; j++) {
					if(all_checks[i][j].checked){
						var comp = all_checks[i][j].id.substring(all_checks[i][j].name.substring(11).length+1);
						var col = find_column_index(comp);
						view_cols.push(col);
						view_cols.push(col+1); // style
						view_cols.push(col+2); // ann
						view_cols.push(col+3); // uncertainty
					}
				}
				update_checkboxes(all_datatables[i], all_sliders[i], all_dashboards[i], all_chart_wrappers[i], view_cols, true, all_chart_names[i]);
			}

			// update morpheus charts
			for(var i = 0; i<all_morph_dashboards.length; i++){
				draw_morph_chart(all_morph_datatables[i], all_morph_sliders[i], all_morph_dashboards[i], all_morph_chart_wrappers[i],true, all_morph_names[i]);
			}

		}
			
			
  </script>
</head>
